%%
% (I): NO control inputs are applied. System is driven only by WGN.
% continous-time model (model of the real physical process) is given by
% \dot{x} = A x + G w
% where w is WGN with intensity Q (possibly time-varying)
% In order to "simulate the system", we construct the discrete-time
% "equivalent model" in the sense that the discrete-time modelâ€™s 
% values of x(t1), x(t2), . . . , are identical (in probabilistic sense)
% to those of the continuous-time model at these particular times. 
% this discrete-time model is given by
% x(k+1) = Ad x(k) + wd
% where Ad = expm(A * Ts) and Ts is the sampling period
% and wd is the discrete-time GWN with covariance matrix Qd given by
% Equation (4-127b). 


clear;

[k,m] = deal(1,2);

Ts = .02; % sampling time of the process
% The equivalent discrete-time system
A = [0, 1;-k/m, 0];
Ad = expm(A*Ts);
H = eye(2); % observation matrix: Noisy observation of the mass position
G = [0;1/m]; % noise-input matrix: 'Additive' process noise: process noise is a horizontal force applied on the mass
%size(w) = [1 1]

Q = 1; % process nosie covariance (cont-time WGN: noise power)
R = diag([1, .5]); % measurement noise covariance (discrete-time WGN)

% f = @(tau) expm(A * (Ts - tau)) * G * Q * G.' * expm(A.' * (Ts - tau));
% Qdd = integral(f, 0, Ts, 'ArrayValued', true);

Qd = ...
[Q*(Ts/(2*k*m) - sin((2*Ts*k^(1/2))/m^(1/2))/(4*k^(3/2)*m^(1/2))),(Q*sin((Ts*k^(1/2))/m^(1/2))^2)/(2*k*m);
(Q*sin((Ts*k^(1/2))/m^(1/2))^2)/(2*k*m),Q*(Ts/(2*m^2) + sin((2*Ts*k^(1/2))/m^(1/2))/(4*k^(1/2)*m^(3/2)))];


tspan = [0, 10]; % the time interval in which the measurements are taken.
% the first measurement is taken at tspan(1) and the last on at tspan(2)
tvec = (tspan(1):Ts:tspan(2)).'; % uniform sampling of the process
% tvec = (nugrid(tspan(1), tspan(2), 801)).'; %non-uniform sampling of the process
N = numel(tvec); % number of measurements taken

% when discretizing, wd has dimension [n x 1] and thus the B matrix in the
% discretized system is the identity matrix.
% take both states in the output for subsequent processing
sysd = ss(Ad, eye(2), eye(2), zeros(2), Ts);

% generating discrete-time process noise signal 
rng('default');
w = mvnrnd([0 0], Qd, numel(tvec)).';  % process noise
v = mvnrnd([0 0], R, numel(tvec)).';  % measurement nosie
x0 = [1;3]; % initial value for the state at time tspan(1) [Generally unkown to the observer]

xx = lsim(sysd, w.', tvec.', x0).';

x = [x0, zeros(2,N-1)];
for i=2:N
    x(:,i) = expm(A*(tvec(i) - tvec(i-1)))*x(:,i-1) + w(:,i);
    x(:,i) = expm(A*(tvec(i) - tvec(i-1)))*x(:,i-1) + w(:,i);
end

cla;
plot(x(:,1), x(:,2), 'b-', 'Marker', 'none');
axis equal; box on; hold on;
plot(x(1,1), x(1,2), 'ro', 'MarkerSize', 7, 'MarkerFaceColor', 'r');

%% kalman filter loop
xhat = zeros(2,N); % corresponding to each measurement there is an estimate
P = zeros(2,2,N); % uncertainty in the estimate

z = x + v; % noisy observations of the state process x(.,.) at sample times in tspan
xhat0 = [1.5;0];
P0 = 5*eye(2);

% x_ are the best estimates of x based on all previous observations, just
% before the new measurement is taken.

tt1vec = [];
xhatvec = [];

tt2vec = [];
phatvec = [];

K = zeros(2,2,N);
for i=1:N
    if i==1
        % your knowledge of the process just before the first measurement
        % is taken. If you have information about the process in the other
        % previous time < t0, you can propagate it into the time t0(-) using
        % the propagation equations.
        x_ = xhat0; % xhat @ t = t0(-)
        P_ = P0;  % P    @ t = t0(-)
    end

    % 1. process the measurement by updating the estimate and its
    % covariance
    K(:,:,i) = P_ * ((H.') / (H*P_*H.' + R));
    xhat(:,i) = x_ + K(:,:,i)*(z(i) - H*x_);
    P(:,:,i) = P_ - K(:,:,i)*H*P_;

    % 2. propagate the estimate until the next measurement is obtained. The
    % estimate moves under the action of the vector field. Interval of
    % integration [t_{i}, t_{i+1}]
    if i~=N
%     [tt1,xx] = ode45(@(t,x) x_odefun(t,x,A),    [tvec(i), tvec(i+1)], xhat(i));
%     [tt2,pp] = ode45(@(t,p) p_odefun(t,p,A,Q,G),[tvec(i), tvec(i+1)], P(i));
%     x_ = xx(end);
%     P_ = pp(end);

        x_ = Ad * xhat(:,i);
        P_ = Ad * P(:,:,i) * Ad.' + Qd;


%     tt1vec = [tt1vec; tt1];
%     xhatvec = [xhatvec; xx];
% 
%     tt2vec = [tt2vec; tt2];
%     phatvec = [phatvec; pp];


    end
end


plot(xhat(1,:), xhat(2,:), 'k-x', 'MarkerSize', 4, 'DisplayName', 'estimates of x(.,.)');
% plot(tt1vec, xhatvec, 'k-');
return;
pu = xhat.' + 2*sqrt(P.');
pl = xhat.' - 2*sqrt(P.');
sp2 = cshade(tvec, pl, pu);
set(sp2, 'DisplayName', '95% confidence region');

dtvec = diff(tvec);
if dtvec(1) ~= dtvec(2)
    title({['Q = ', num2str(Q), ' | R = ', num2str(R)], 'Nonuniform grid'});
else
    title({['Q = ', num2str(Q), ' | R = ', num2str(R)], 'Uniform grid'});
end

nexttile(2);
plot(tvec, P, 'b-o');
plot(tt2vec, phatvec, 'k-');
box on;

return;

mx = @(t) ...
[cos((k^(1/2)*t)/m^(1/2)), (m^(1/2)*sin((k^(1/2)*t)/m^(1/2)))/k^(1/2);
-(k^(1/2)*sin((k^(1/2)*t)/m^(1/2)))/m^(1/2), cos((k^(1/2)*t)/m^(1/2))] * x0;

P = @(t) ...
[Q*(t/(2*k*m) - sin((2*k^(1/2)*t)/m^(1/2))/(4*k^(3/2)*m^(1/2))), (Q*sin((k^(1/2)*t)/m^(1/2))^2)/(2*k*m);
(Q*sin((k^(1/2)*t)/m^(1/2))^2)/(2*k*m), Q*(t/(2*m^2) + sin((2*k^(1/2)*t)/m^(1/2))/(4*k^(1/2)*m^(3/2)))];


mxvec = cell2mat(arrayfun(mx, tvec, 'UniformOutput', false));
%%


cla;
% plot(x(1,1), x(1,2), 'r*');
% hold on;
% plot(x(:,1), x(:,2), 'bo');
plot(mxvec(1,:), mxvec(2,:), 'k-');
hold on; grid on; box on; axis equal;
xlabel('x'); ylabel('y');

X = cellipse(mx(tvec(1)), P(tvec(1)), 2);
cellipse_patch = patch('XData',X(1,:),'YData',X(2,:), 'FaceColor', 'r', 'FaceAlpha', .1);
cellipse_com = plot(mxvec(1,1), mxvec(2,1), 'k*');
for i=1:30:numel(tvec)
    X = cellipse(mx(tvec(i)), P(tvec(i)), 1);
%     patch('XData',X(1,:),'YData',X(2,:), 'FaceColor', 'r', 'FaceAlpha', .1);
    set(cellipse_patch, 'XData', X(1,:), 'YData', X(2,:));
    com = mx(tvec(i));
    set(cellipse_com, 'XData', com(1), 'YData', com(2));
    pause(.2);
end

P0 = zeros(2);
% [t,Pt] = ode45(@P_odefcn, tvec, zeros(2));

function X = cellipse(mu, P, c)
%C-Ellipse: Covariance ellipse of a bivariate normal distribution
% given the covariance matrix and the mean vector of a bivariate Gaussian
% distributoin, the c-ellipse is returned:
% equation of the ellipse is given by
% (x-mu)' inv(P) (x-mu) - c = 0
% where x is the 2D position vecotr [x,y]
%
% X(1,:) is the x-component of the ellipse
% X(2,:) is the y-component of the ellipse
%
% c=1 corresponds the  q-ellipse
% c=2 corresponse the 2q-ellipse
% ...
%
% example:
% P = [2.9087, 2.4783;
%     2.4783, 6.0913]
% mu = [1;2];
% 
% X = cellipse(mu, P, 1);
% patch('XData',X(1,:),'YData',X(2,:), 'FaceColor', 'r', 'FaceAlpha', .2);

[Q,L] = eig(P);
R = (Q /(sqrt(L))).';
Ri = Q*sqrt(L);

theta = 0:.05:2*pi;
y = sqrt(c)*[cos(theta);sin(theta)];
X = (Ri * y) + mu;
end

function dPdt = P_odefcn(t,P)
P = zeros(2);
A = [0 1;-1 0];
dPdt = A*P + P*A.' + eye(2);
end


%%
function dxdt = x_odefun(t,x,A)
dxdt = A*x;
end

function dpdt = p_odefun(t,p,A,Q,G)
dpdt = A*p + p*A.' + G*Q*G.';
end

